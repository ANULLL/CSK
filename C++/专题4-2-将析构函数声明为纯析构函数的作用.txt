
一 将父类的析构函数声明为虚析构函数是为了实现多态。

二 为什么有时候要将析构函数声明为纯虚析构函数？
例程:
#include <iostream>
using namespace std;

class A{
public:
	A(){cout<<"A()"<<endl;}
	//~A(){cout<<"~A()"<<endl;}
	virtual ~A() = 0;//{cout<<"~A()"<<endl;}
};

A::~A(){cout<<"~A()"<<endl;}; //2 实现

class B:public A{
public:
	B(){cout<<"B()"<<endl;}
	~B(){cout<<"~B()"<<endl;}
};

int main(){
	//A a;  //error 抽象类不能实例化
	//B b;  //1 error 因为父类的析构函数没有实现,所以需要为父类的纯虚析构函数进行定义。
	B b;    //2
	return 0;
}

  当将某个类的析构函数声明为纯析构函数时，又不想声明其他的虚函数时，此时纯虚析构函数就起作用了。作用就是标志该类是抽象类，不再需要其他的虚函数标志此类为抽象类。该类只能作为父类，不能实例化。 （相当于java中的接口）
  注意:当某个类继承此种抽象类的时候，该类的纯虚函数必须在类外定义，否则创建子类对象时会出错。
  
