					C++自学总结day04--
涉及内容:
	友员函数和友员类
	运算符重载
	三原则
	多重继承和虚继承
	异常和内部类

一 复习上次
 1  指针和引用的5大不同点？
    (1) 引用不能修改，指针可以
    (2)	引用必须被初始化，指针不需要  A *p;//ok   A &p; //eror
    (3) 引用不能为NULL,指针可以
    (4) 引用只是别名，不是拷贝，又不是地址。而指针代表的就是变量的地址。
    (5) 应用名本身没有地址，而指针变量名有地址。
	 
  2 在C++头文件中，声明static函数(不是成员函数)的作用？
    (1) 缩小了作用域，该函数只能在包含该头文件的源文件中实现并使用，脱离本源文件文件之后无法使用。
例如:    a.h                       a.cc
        static void fn()；	   #include　"a.h"
                                   static void fn(){cout<<"static"}//此时，fn()只能在a.h中使用要想被其他的文件调用，需要在a.cc中写一个非 static函数，如void fn2(){fn();} ,然后其他文件可以通过调用fn2()函数，从而间接的调用fn();

  3 虚函数（构造函数不能为虚函数，析构函数可以为虚函数）
class A{
public:
	virtual A(){}       //error 为什么构造函数不能为虚？
	virtual ~A(){}      //尽量将析构函数声明为虚函数。存在多态时父类的析构函数必须为虚析构函数。
	virtual	void fn(){} //ok 虚函数的地址存放在虚函数表中(V TABLE),虚函数表指针指向此虚函数表。
	virtual	void fn2(){} //ok 
	void fn3()      //普通函数，函数名就是地址，调用的时候就会找到。
}
   虚函数在C++中是为实现多态而存在。
   实现多态是有代价的。
  (1) 虚函数表指针 指向 虚函数表(V TABLE:存放虚函数的地址)：虚函数表指针也是类的一个成员。(隐式存在)
  (2)创建对象的过程:(1) 先分配内存空间。
              (2) 再调用构造函数(初始化为成员分配的空间)
  (3)！！！为什么构造函数不能为虚？
   如果构造函数为虚函数的话,当创建对象的时候，调用此虚构造函数进行初始化操作，其中虚函数表指针也是对象的一个成员，需要构造函数进行初始化，但是此时我们连虚构造函数的地址都找不到，何以找到虚函数表指针，何以进行初始化？那么对象的内存空间不就是乱七八糟的吗？  综上，构造函数不能是虚函数。
  (4) ！！！为什么存在多态时父类的析构函数必须为虚析构函数？
  详细分析见 专题4-1

 4 抽象类:只要一个类中有一个纯虚函数，则该类就是抽象类，该类只能做父类，不能进行实例化。
   (1)析构函数能否为纯虚析构函数？virtual ~A()= 0  //??????
    详见专题4-1

 5 继承特性 private protected private
   继承方式 private protected private
类内部 子类中 外部。
 
 6 多态的概念:对一个动作执行多种状态。
  （1） 生活中的多态
车辆
机动车 人力车 畜力车
停
踩刹车  捏刹车 拉缰绳
cut
演员    理发师  医生
  （2）多态的实现条件
      继承
      虚函数
      覆盖
      父类的指针或引用访问子类的实例。
以下哪些情况可以实现多态？  见专题3-2	
        A a;
	B b;
	A* p = &a;      //NO 无多态
	A* p =&b;       //YES 父类指针访问子类对象
	A& p = a;       //NO 无多态 普通的引用
	A& p = b;       //YES 父类引用访问子类对象
	A* p = new B;   //YES 父类指针访问子类对象
	A& p  =new B;   //NO 无多态 类型不匹配
	A& p  =*(new B); //NO 无多态  C++不允许此语法
	A p = b;         //NO 无多态 copy construct  A p(b); 子类的对象永远可以当成父类对象使用。
  
   
 二 友员函数和友员类
  1 友元是内部授权的，它不是成员，友元声明不受访问修饰符的影响，里面没有this，友元函数的声明和定义可以不分开。
    友元关系不能反转，不能传递，也不能继承。
#include <iostream>
using namespace std;
//友员不受修饰符的限制
class C{
private:
	int i;
	//编译器 后门授权
	friend void access(const C& c); //友员函数
	friend class D; //友员类
public:
	//friend void access(const C& c); //友员函数
	C(int i = 10):i(i){}
};

void access(const C& c){
	cout<<c.i<<endl;
}

class D{
public:
	void twice(C&c){
		c.i *= 2;
	}
};

int main(){
	C c;
	access(c);
	D d;
	d.twice(c);
	access(c);
	return 0;
}


三 运算符的重载
 1.实现运算符重载,就是编写相应的运算符函数。
   函数必须以operator开头
   实现方式: 1. 友员方式  2.成员方式
详细见专题 4-3
  注意friend Complex operator++(Complex& c,int);	//后自增 int的作用只是为了区分前增，别无它用。系统默认给他赋0值
 
 2 注意:C++中很多运算符都被语言本身重载，如果语言已经重载，我们不能再写和语言重载一样的函数。
 例如:string operator=(Complex&c1,Complex&c1);  //语言本身已经重载，我们不能再写

 3 错误：‘Complex operator=(Complex&, Complex&)’ 必须是一个非静态的成员函数????
分析:

 4 运算符= [] 这两个运算符必须以成员函数的形式进行重载。

作业: 1 写一个复数类(实部，虚部 + - * / (前)++ (前)-- 后++(int) 后-- << >>)
      2 写一个String类(包含String里面的所有)(+,+=(相当于c语言中的strcat),=(strcpy),[])
 
