				C++自学总结day02
涉及内容:
	

一 复习上次
  1 对象（抽象成）->类，对象是具体的，单个的一个实体
    类是抽象的，是一个模板。
    例如:类（学校)，对象（经济学院）

  2 使用对象的流程:
	(1)定义（创建类）类  class A{};
	(2)创建对象(定义变量)         A a;  （自定义的类型优先级最高）
		A  a;
		int i;
		a = i; //ok  (类A拥有一个带int型参数的构造函数)
	(3)使用对象     a.fun();//OO     show(a) //OP
  3 面向过程 VS 面向对象
	(1)软件复用(软件重用，层次)：c语言重用函数，C++类(若干的数据和操作)
	(2)设计和使用角度:(例如设计一个屏幕移动)
	  C：  struct Screen{数据};  move(Screen *p)
	  C++: class Screen{数据和操作}; Screen s; s.move();
	(3)源于生活:考虑问题的方式方法决定了我们的编码。
	例如:开车去汉口
	步骤:面向过程:按照步骤一步一步的做事。
	     面向对象:车.go();
      	（4）可扩展性，通用性:(例如下围棋中的悔棋)
	面向过程:牵一发动全身(面向过程的可扩展行和可维护性不高)：下棋人，棋盘，棋子，下棋规则。从而设计各自的方法。（宏观OO，微观OP）
 	面向对象:

 4 构造函数(构造器)
特点:名字与类名相同，无参无返回值。
功能:构造函数是创建对象的标志。
对象的生命周期开始的时候 自动 调用。
 
 5 函数重载(overload)：函数名相同，参数列表不同，与返回值无关。
 
 6 析构函数:功能和构造函数相反。当对象的生命周期结束时 自动 调用。
 
 7 初始化列表:A(int i):成员(形参){this->i = i;}; (VIP)
 以下三种情况必须使用初始化成员列表进行初始化:
   (1)需要初始化的成员是对象的情况
class B{B(int i){}};
class A{int i;int &j;B b};
   (2)需要初始化const修饰的类成员 
   (3)需要初始化引用成员数据 
   (4)需要初始化父类成员

 以下两种情况必须使用构造函数进行初始化
   (1) 数组
   (2) 结构体
其它的成员既能在构造函数中初始化，也能用初始化成员列表进行初始化。

 8 this指针：指向当前对象。一个对象对应一个this
class C{
	int m;
public:
	C(){cout<<this<<endl;};
}
int main()
{
	C c,c2;
	cout<<&c<<&c2<<endl;
}
分析:共打印三条语句
 
 9 形参默认值 

 10 各种对象
  (1) 栈对象
  (2) 堆对象
  (3) 全局对象
  (4) 静态全局对象
  (5) 无名对象
  (6) 引用对象
  (7) 常量对象
  (8) 对象指针

class A{
   int i;
public:
   A(int i=3){}
   void show(){}
   vois show() const{}   //常函数:在函数中不能修改变量的值
}；

A a2(){
	return A();
}

void stackObject(){
  A a;          //栈对象
  A a2();	//函数的声明(function declare)，不能创建对象。
  A a3(3);	//栈对象
  A a4 = 4;	//栈对象 等价于 A a4(4);
  A();		//无名对象
  A(6)		//无名对象
  A a5 = A(5);	//OK A(5)创建一个无名对象然后拷贝一份给a5,然后自己立即销毁
}

void heapObject(){
  A *p = new A(); //堆对象  A *p = new A(20)
  delete p;
  
  p = new A[2];   //在堆中创建2个连续分配的类数组,p指向数组首地址，p本身在栈中。
                  //2个堆对象分别为p[0],p[1]
  delete p ;      //只能删除第一个。
  delete[] p;     //删除p[0],p[1]
}

int i;
A  a  ;           //全局对象(类比全局变量)，在main函数前创建。

void staticObject(){
  static A a;     //第一次执行这行代码时创建对象(创建初始化一次)，程序结束时销毁
}

void  fn4(){
   A a,a2;          //引用终生制，不能再是别个对象的引用
   A &b = a; //OK     alias引用对象必须初始化,从此b只能是a的引用(别名)。
// b = a2;   //	ERROR 赋值(asigment)
   A &c = b; //OK     a,b,c是同一个对象	
}


void constObject(){
   const A a;  //常对象只能访问常函数
   a.show();   //调用的是常函数
   A a2;     
   a2.show();  //普通对象优先调用普通函数(普通函数优先级高于常量函数)，如果没有普通函数则调用常函数。
}

常函数 VS 返回值为常量的函数
 void show() const{}   VS  const void show(){}


二  OOP进阶
 1 注意只有一个参数且有默认值的函数   VS  无参函数
	A():data(0){
		cout<<"A()"<<endl;
	};
	A(int i =0):data(i){
		cout<<"A("<<data<<")"<<endl;
	}
他们不是函数的重载，重复了。

 2 类型转换有两种方法:
   (1) (类型) 变量  
   (2)  类型  (变量)

 3 自定义的类型 优先级高于 固有的类型
   A a5 = A(5);   或者 A a5 = (A)5  
分析:尽管5是int型变量，但是类A的优先级高于int，所以优先转化为A

 4 引用(&)  VS 指针(*)
引用:仅仅是给变量取别名，是同一段内存的多个映射。因此引用本身不占内存。 	int &j = i;   //引用是终身制
指针:本身栈相对应的内存空间。

 5 int& fn(){
	int n =5;
	int &n2 =n;
	return n2;  //不能返回局部变量的引用 error
	//return n; //不能返回局部变量的引用 error
}

int& fn2(){
	static int n = 5
	int &n2 = n;
	return n2;
	//return n;  //ok
}

  6 static的用法（既可以修饰成员数据，也可以修饰成员函数）
   （1）对象拥有独立的数据，如果想要该类的所有的对象都共享同一份数据，要用static修饰
   （2）先有类，再有对象
       static修饰的成员属于类(所有对象共享)，普通成员是属于对象(每个对象独有)
所以静态成员不能访问非静态成员，但是非静态成员可以访问静态成员。
    (3) 静态成员必须在类外部进行初始化:
	string Student::teacher = "郭老师";
	string Student::classroom = "计科(1)班";

  7 拷贝构造函数
    (1)拷贝构造函数的经典写法:
       B(const B& b){
	  cout<<"B(copy)"<<endl;
	};
    不能写成:B(B b){};  //会产生死循环，所以应该用引用解决.B(B &b){};
为了保护引用，所以加const修饰。
    （2）调用拷贝构造函数时，只是将实参的值赋给形参，不会给成员赋值，所以需要我们手动赋值。C(C &c):i(c.i){cout<<"C(copy)"<<endl;}
    （3）深拷贝 VS 浅拷贝
默认的拷贝构造函数会逐字节地拷贝旧对象的成员到新对象的成员。会造成成员中有的指针指向的数据无法拷贝。详细见专题2-2

  8  string类型
    string类型是一个C++中一个新的数据类型。
    支持:string s1,s2; s1 = s2;

作业:1 利用static设计一个单子模式（单例模式），即设计一个类，该类只能创建一个对象。
   详细见专题2-3

  
