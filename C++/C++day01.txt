			C++自学总结day01--OOP
涉及内容:
	程序设计简史
	类和对象
	构造函数
	封装和隐藏
	对象的内存结构
一 程序设计简史
 1 gcc中的汇编器:as
 2 wps是原金山老总 求伯君 利用汇编语言编写。
 3 面向机器 面向过程 面向对象 面向组件 面向服务
 4 C VS C++ (VIP)
 5 结构体是C和C++之间的桥梁。
 6 C+OOP+泛型+STL(标准模板库) = C++ 
 7 #include <iostream.h>  VS #include <iostream>
			     using namespace std; //标准命名空间
 8 cout>>"hello world">>endl; //这里的移位运算符是被重载过的。
 9 C++中标准的头文件都不用.h,除非自己写的。
 10 如果不用命名空间,可如下写:
 #include <iostream>   //C++
//using namespace std; //命名空间  可以自己写命名空间

int main(){
	std::cout<<"hello world!"<<endl; //::域运算符，不推荐这样写 cout是一个流对象 <<为流运算符  endl(end line)
	cout<<"please input your name:";
	int age;
	cin>>age;
	cout<<"age">>age>>endl;
	return 0;
}

二 类和对象
 0 C  VS C++
   c语言中数据和对数据的操作是分离的。
 1 Everyting is object 
 2 对象:具体的。
        任何对象都有两样东西:属性 行为
 	对象是类的实例。
        Time t; //对象为类的变量就是对象
 3 类:类是对象的模板。从对象中抽象出类，类是对象的类型。
 3 封装:对象同时具有属性和行为两项特性。
 4 注意在C语言中为一个函数传一个结构体参数时，应当传一个结构体指针变量，这样只传了四个字节的内容，方便快捷。
 如果传一个结构体变量的话，就会增大内存开销。
 例如:void show(struct Time *p)   VS  void show(struct Time t)
 
 6  C语言中的struct VS C++中的 struct
//C++中的结构体和C语言中的结构体有很大的区别
//C++中声明变量时，struct类型修饰符号可以改变
//struct在C++的本质就是class! 但是有一点区别,见7,其它的是一摸一样的。

 7 C++中的类 VS C++中的结构体  （就这么一个区别）
  类(class):默认的成员都为私有的
  结构体(struct)：默认的成员都为公有的
  类 对象(Time是t的类型,t就是Time类型的一个变量)
  this是一个隐含指针变量，指向当前对象(代替手动传递的p)
 
 8 类中包含两种成员:
  a 成员变量(属性):数据成员
  b 成员函数(行为):构造函数，析构函数(不能重载)，普通成员函数

 9 析构函数:~Time(){};
  a 析构函数在默认的构造函数前面加一个~符号
  b 析构函数不能重载，也没用参数。
  c 析构函数用于销毁对象的成员。

 10 this指针，指向当前类的对象。见专题1-2
  
 11 任何变量都有地址，同理，对象也有地址 &对象名 即为对象的地址。
 
四 构造函数(是创建对象的必经之路)
 1 创建一个对象，一定要调用一个构造函数
   构造函数；没有显示定义时,系统会自动给我们一个默认无参的构造函数。
   
 2 构造函数的特点：
    a 名字和类名相同
    b 没有任何返回类型
    c 构造函数可以私有
class A{
	int n;
	const int t; //常量的初始化,只能用初始化列表
private:
	A():t(0){};  //构造函数可以私有，但是不能调用它来创建对象。
}

 3 没有返回值  VS  没有返回类型
  void show(); VS  show();
  
 4 构造函数的作用:初始化成员变量
  Time(int h, int m, int s) {
		printf("three param constructor!\n");
		this->h = h; //解决命令冲突
		this->m = m;
		this->s = s;
	}

 5 函数的重载(overload):
  a 参数名相同
  b 参数列表不同(参数个数，参数类型，参数顺序)。  

 6 访问修饰符 private protected public

 7 输出流都有缓存，输出时必须刷新 ()
void show() {
	//printf("%02d:%02d:%02d\r", this->h, this->m, this->s);
	cout<<h<<":"<<m<<":"<<s<<"\r";
	fflush(stdout); //刷新缓冲区
	}

 8 分离的思想：
  a 所有的类型定义都放到头文件中去
  b 函数的声明和函数的实现分开

 9 类型域作用符(::):（ “::”要紧跟在成员函数前面）
 例如：Time::Time(){};

 void Book::detail(){  //Book::要紧跟在成员函数前面
	cout<<"name = "<<name<<",pageNum = "<<pageNum<<",type="<<type<<endl;
}

 10 形参默认值:
void order(char *name,int n=1){  //形参默认值
	cout<<"点了"<<n<<"份"<<name<<endl;
 }  //如果在调用此函数时，没有给第二个参数赋值，则默认的为1
      如果给第二个参数赋了值，则覆盖默认值。

 11 C++中在类中不能直接给成员变量赋值。
  class A{
	int n = 100; //error
  }；
    
 12 对于成员常量只能用初始化列表赋值
class A{
	int n;
	const int t; //常量的初始化,只能用初始化列表
public:
	A(int n,int t):t(t){
		cout<<"A("<<n<<")"<<endl;
		this->n = n;
	}

	void show(){
		cout<<"n="<<n<<",t="<<t<<endl;
	}
};
  
 13 C++中的非构造函数必须写明返回类型，否则错误。

 14 析构的顺序和构造的顺序相反。
 
  全局对象和栈对象 都会由系统自动析构，而堆对象需要手动析构delete 堆对象指针。

 15 注意:当需要创建一个对象时，一定会调用构造函数。
         当一个对象的生命周期到了之后，一定会调用析构函数。

五 封装和隐藏
  1 封装:对象同时具有属性和行为两项特性。
  2 函数的重载:函数的重载(overload):
    a 参数名相同
    b 参数列表不同(参数个数，参数类型，参数顺序)。
    c 与返回值无关

六 对象的内存结构(见专题1-3)
  1 栈对象
  2 堆对象
  3 全局对象
  4 局部静态对象
  5 无名对象：没有名字，一次性析构的对象。
  6 常量对象：只能调用常函数
  7 对象引用：
  8 对象指针：A *a = new A(); //a就为对象指针


七 引用(取别名，如同硬链接)
  1 &符号的多用
     1. &i取地址 
     2. 3&4 按位与 
     3. a>0 && b<0 逻辑与 
     4.  int &i = j; 定义一个应用类型

  2 


作业:
1 C语言能否做面向对象的设计。（可以）见专题1.1
  
2 有哪一些成员必须用初始化列表初始化，有哪一些成员必须用构造函数进行初始化。
哪些成员既可以用初始化列表又可以用构造函数初始化？
以下三种情况必须使用初始化成员列表进行初始化:
 (1)需要初始化的成员是对象的情况
 (2)需要初始化const修饰的类成员 
 (3)需要初始化引用成员数据 
 (4)需要初始化父类成员
以下两种情况必须使用构造函数进行初始化
   (1) 数组
   (2) 结构体
其它的成员既能在构造函数中初始化，也能用初始化成员列表进行初始化。

3 一个空类到底有什么？一个空类的大小？
有默认的构造函数，拷贝默认构造函数，默认拷贝赋值操作符，默认析构函数。
一个空类的sizeof(A)大小为:1

4  一个空类的sizeof(A)大小为:1 为什么？
原因:那是被编译器插进去的一个char,使得这个class的实体在内存中配置独一无二的地址。   



























